/*
 * Copyright (C) Techfaith 2002-2005.
 * All rights reserved.
 *
 * This software is covered by the license agreement between
 * the end user and Techfaith, and may be 
 * used and copied only in accordance with the terms of the 
 * said agreement.
 *
 * Techfaith assumes no responsibility or 
 * liability for any errors or inaccuracies in this software, 
 * or any consequential, incidental or indirect damage arising
 * out of the use of the software.
 *
 */
/*
 * We_Hdr.c
 *
 * Created by Anders Edenwbandt, Mon Sep 09 08:29:29 2002.
 *
 * Revision history:
 */
#include "We_Cfg.h"
#include "We_Def.h"
#include "We_Lib.h"
#include "We_Chrs.h"
#include "We_Chrt.h"
#include "We_Cmmn.h"
#include "We_Mem.h"
#include "We_Hdr.h"


/************************************************************ 
 * Constants
 ************************************************************/

#define WE_HDR_INITIAL_SIZE            10
#define WE_HDR_SIZE_INCREMENT          10

#define WE_HDR_STR_DOUBLE_QUOTE  "\""
#define WE_HDR_STR_EQUAL         "="
#define WE_HDR_STR_SEMI_COMMA    ";"

#define WE_HDR_CH_DOUBLE_QUOTE   '"'
#define WE_HDR_CH_EQUAL          '='
#define WE_HDR_CH_SEMI_COMMA     ';'
#define WE_HDR_CH_BACKSLASH      '\\'
#define WE_HDR_CH_BLANK          ' ' 

#define WE_HDR_IS_QUOTED_STRING(s)  ((strlen(s) > 2) && \
        (s[0] == WE_HDR_CH_DOUBLE_QUOTE) && \
        (s[strlen(s)-1] == WE_HDR_CH_DOUBLE_QUOTE))

#define WE_HDR_MEM_FREE_AND_RESET(module, p) \
      if (p) { WE_MEM_FREE(module, p); p = NULL; }

/**************************************************
 * Type definitions 
 ***************************************************/

/*
 * The header elements
 */
typedef struct {
  int   name_i;         /* Well-known header index */
  char *name;           /* Unknown header as string, or NULL if well-known */
  char *value;          /* Value, always != NULL */
} we_hdr_element_t;

/* 
 * The header table
 */ 
struct we_hdr_st {
  WE_UINT8 module;        /* Module that created this header struct */
  int       max_size;      /* Number of elements in the 'element' array */
  int       size;          /* Number of elements used in the 'element' array */
  int       last_added;    /* Index of the element that was added to last */
  we_hdr_element_t *element; /* Array of elements */
};


/************************************************************
 * Hash table etc. for header-names generated by mkhash.pl
 ************************************************************/ 

/************************************************************
 * Hash table generated by mkhash.pl
 ************************************************************/

#define WE_HDR_NAME_HASH_TABLE_SIZE              157
#define WE_HDR_NAME_STRING_TABLE_SIZE            102

static const unsigned char we_hdr_name_hash_table[] = {
  57, 255, 255, 89, 18, 47, 255, 255, 84, 255,
  67, 68, 73, 34, 255, 255, 255, 0, 13, 52,
  35, 31, 255, 255, 87, 255, 255, 48, 255, 28,
  255, 83, 24, 26, 255, 54, 255, 255, 255, 255,
  36, 49, 7, 86, 255, 32, 5, 46, 255, 255,
  11, 255, 101, 2, 9, 41, 255, 6, 69, 94,
  63, 1, 51, 10, 39, 19, 71, 27, 255, 8,
  255, 99, 22, 42, 72, 66, 255, 40, 77, 100,
  255, 78, 255, 80, 255, 255, 255, 255, 255, 255,
  255, 255, 70, 25, 255, 93, 62, 97, 96, 255,
  29, 255, 20, 23, 58, 82, 21, 255, 12, 98,
  88, 255, 50, 60, 91, 16, 3, 255, 17, 255,
  43, 255, 55, 255, 255, 44, 81, 59, 65, 255,
  37, 255, 85, 90, 255, 14, 255, 30, 45, 15,
  56, 61, 255, 95, 38, 64, 74, 255, 255, 255,
  75, 4, 53, 76, 92, 79, 33
};

static const we_strtable_entry_t we_hdr_name_strings[] = {
  {"accept", WE_HDR_ACCEPT},
  {"accept-charset", WE_HDR_ACCEPT_CHARSET},
  {"accept-encoding", WE_HDR_ACCEPT_ENCODING},
  {"accept-language", WE_HDR_ACCEPT_LANGUAGE},
  {"accept-ranges", WE_HDR_ACCEPT_RANGES},
  {"age", WE_HDR_AGE},
  {"allow", WE_HDR_ALLOW},
  {"authorization", WE_HDR_AUTHORIZATION},
  {"cache-control", WE_HDR_CACHE_CONTROL},
  {"connection", WE_HDR_CONNECTION},
  {"content-base", WE_HDR_CONTENT_BASE},
  {"content-encoding", WE_HDR_CONTENT_ENCODING},
  {"content-language", WE_HDR_CONTENT_LANGUAGE},
  {"content-length", WE_HDR_CONTENT_LENGTH},
  {"content-location", WE_HDR_CONTENT_LOCATION},
  {"content-md5", WE_HDR_CONTENT_MD5},
  {"content-range", WE_HDR_CONTENT_RANGE},
  {"content-type", WE_HDR_CONTENT_TYPE},
  {"date", WE_HDR_DATE},
  {"etag", WE_HDR_ETAG},
  {"expires", WE_HDR_EXPIRES},
  {"from", WE_HDR_FROM},
  {"host", WE_HDR_HOST},
  {"if-modified-since", WE_HDR_IF_MODIFIED_SINCE},
  {"if-match", WE_HDR_IF_MATCH},
  {"if-none-match", WE_HDR_IF_NONE_MATCH},
  {"if-range", WE_HDR_IF_RANGE},
  {"if-unmodified-since", WE_HDR_IF_UNMODIFIED_SINCE},
  {"location", WE_HDR_LOCATION},
  {"last-modified", WE_HDR_LAST_MODIFIED},
  {"max-forwards", WE_HDR_MAX_FORWARDS},
  {"pragma", WE_HDR_PRAGMA},
  {"proxy-authenticate", WE_HDR_PROXY_AUTHENTICATE},
  {"proxy-authorization", WE_HDR_PROXY_AUTHORIZATION},
  {"public", WE_HDR_PUBLIC},
  {"range", WE_HDR_RANGE},
  {"referer", WE_HDR_REFERER},
  {"retry-after", WE_HDR_RETRY_AFTER},
  {"server", WE_HDR_SERVER},
  {"transfer-encoding", WE_HDR_TRANSFER_ENCODING},
  {"upgrade", WE_HDR_UPGRADE},
  {"user-agent", WE_HDR_USER_AGENT},
  {"vary", WE_HDR_VARY},
  {"via", WE_HDR_VIA},
  {"warning", WE_HDR_WARNING},
  {"www-authenticate", WE_HDR_WWW_AUTHENTICATE},
  {"content-disposition", WE_HDR_CONTENT_DISPOSITION},
  {"x-wap-application-wid", WE_HDR_X_WAP_APPLICATION_ID},
  {"x-wap-content-uri", WE_HDR_X_WAP_CONTENT_URI},
  {"x-wap-initiator-uri", WE_HDR_X_WAP_INITIATOR_URI},
  {"accept-application", WE_HDR_ACCEPT_APPLICATION},
  {"bearer-indication", WE_HDR_BEARER_INDICATION},
  {"push-flag", WE_HDR_PUSH_FLAG},
  {"profile", WE_HDR_PROFILE},
  {"profile-diff", WE_HDR_PROFILE_DIFF},
  {"profile-warning", WE_HDR_PROFILE_WARNING},
  {"expect", WE_HDR_EXPECT},
  {"te", WE_HDR_TE},
  {"trailer", WE_HDR_TRAILER},
  {"x-wap-tod", WE_HDR_X_WAP_TOD},
  {"content-wid", WE_HDR_CONTENT_ID},
  {"set-cookie", WE_HDR_SET_COOKIE},
  {"cookie", WE_HDR_COOKIE},
  {"encoding-version", WE_HDR_ENCODING_VERSION},
  {"x-wap-security", WE_HDR_X_WAP_SECURITY},
  {"x-wap-loc-invocation", WE_HDR_X_WAP_LOC_INVOCATION},
  {"x-wap-loc-delivery", WE_HDR_X_WAP_LOC_DELIVERY},
  {"x-wap-cpitag", WE_HDR_X_WAP_CPITAG },
  {"x-wap-push-provurl", WE_HDR_X_WAP_PUSH_PROVURL},
  {"x-wap-push-accept", WE_HDR_X_WAP_PUSH_ACCEPT},
  {"x-wap-push-accept-charset", WE_HDR_X_WAP_PUSH_ACCEPT_CHARSET},
  {"x-wap-push-accept-encoding", WE_HDR_X_WAP_PUSH_ACCEPT_ENCODING},
  {"x-wap-push-accept-language", WE_HDR_X_WAP_PUSH_ACCEPT_LANGUAGE},
  {"x-wap-push-accept-appid", WE_HDR_X_WAP_PUSH_ACCEPT_APP_ID},
  {"x-wap-push-maxmsgsize", WE_HDR_X_WAP_PUSH_MSG_SIZE},
  {"x-wap-push-accept-maxpushreq", WE_HDR_X_WAP_PUSH_ACCEPT_MAX_PUSH_REQ  },
  {"x-wap-terminal-wid", WE_HDR_X_WAP_TERMINAL_ID},
  {"x-wap-push-info", WE_HDR_X_WAP_PUSH_INFO },
  {"x-wap-push-status", WE_HDR_X_WAP_PUSH_STATUS    },
  {"x-wap-push-ota-version", WE_HDR_X_WAP_PUSH_OTA_VERSION},
  {"x-wap-bearer-indication", WE_HDR_X_WAP_BEARER_INDICATION},        
  {"x-wap-authenticate", WE_HDR_X_WAP_AUTHENTICATE},
  {"x-wap-authorization", WE_HDR_X_WAP_AUTHORIZATION},
  {"x-wap-profile", WE_HDR_X_WAP_PROFILE},
  {"x-wap-profile-diff", WE_HDR_X_WAP_PROFILE_DIFF},
  {"x-wap-profile-warning", WE_HDR_X_WAP_PROFILE_WARNING},
  {"x-up-tpd-e2e-headers", WE_HDR_X_UP_TPD_E2E_HEADERS},
  {"x-forwarded-for", WE_HDR_X_FORWARDED_FOR},
  {"content-transfer-encoding", WE_HDR_CONTENT_TRANSFER_ENCODING},
  {"refresh", WE_HDR_REFRESH},
  {"x-drm", WE_HDR_X_DRM},
  {"set-cookie2", WE_HDR_SET_COOKIE2},
  {"cookie2", WE_HDR_COOKIE2},
  {"x-vodafone-3gpdpcontext", WE_HDR_X_VODAFONE_3GPDP_CONTEXT},
  {"x-oma-drm-separate-delivery", WE_HDR_X_OMA_DRM_SEPARATE_DELIVERY},
  {"rights-issuer", WE_HDR_RIGHTS_ISSUER},
  {"content-name", WE_HDR_CONTENT_NAME},
  {"content-description", WE_HDR_CONTENT_DESCRIPTION},
  {"content-vendor", WE_HDR_CONTENT_VENDOR},
  {"icon-uri", WE_HDR_ICON_URI},
  {"encryption-method", WE_HDR_ENCRYPTION_METHOD},
  {"x-vodafone-content", WE_HDR_X_VODAFONE_CONTENT}
};

const we_strtable_info_t we_hdr_names = {
  we_hdr_name_hash_table,
  WE_HDR_NAME_HASH_TABLE_SIZE,
  WE_TABLE_SEARCH_BINARY,
  we_hdr_name_strings,
  WE_HDR_NAME_STRING_TABLE_SIZE
};

/************************************************************
 * Hash table for language names generated by mkhash.pl
 ************************************************************/

#define WE_LANGUAGES_HASH_TABLE_SIZE                 211
#define WE_LANGUAGES_STRING_TABLE_SIZE               139

static const unsigned char we_languages_hash_table[] = {
  97, 18, 255, 255, 128, 33, 86, 255, 255, 255,
  255, 118, 22, 255, 255, 255, 255, 113, 255, 255,
  104, 92, 64, 1, 255, 138, 255, 20, 255, 255,
  255, 13, 110, 107, 12, 255, 255, 62, 101, 131,
  116, 255, 255, 34, 82, 255, 125, 134, 53, 32,
  50, 255, 31, 255, 16, 5, 255, 133, 255, 47,
  255, 255, 255, 255, 255, 78, 37, 40, 77, 255,
  35, 74, 88, 27, 255, 63, 25, 255, 255, 103,
  255, 8, 99, 42, 58, 255, 90, 106, 81, 111,
  124, 52, 255, 7, 115, 67, 136, 49, 66, 114,
  95, 255, 255, 46, 137, 2, 91, 38, 0, 21,
  255, 255, 56, 15, 255, 72, 255, 109, 44, 11,
  23, 255, 255, 85, 19, 60, 255, 130, 119, 255,
  17, 93, 80, 41, 255, 255, 68, 30, 255, 255,
  4, 255, 255, 3, 255, 39, 105, 69, 255, 255,
  255, 122, 120, 76, 255, 255, 73, 14, 26, 70,
  51, 24, 43, 9, 102, 255, 132, 71, 255, 57,
  126, 255, 255, 255, 135, 123, 36, 112, 6, 79,
  127, 117, 55, 65, 29, 48, 129, 84, 121, 54,
  255, 255, 255, 83, 108, 96, 98, 255, 89, 28,
  45, 87, 75, 255, 10, 94, 255, 61, 100, 255,
  59
};

static const we_strtable_entry_t we_languages_strings[] = {
  {"aa", WE_LANGUAGE_AA},
  {"ab", WE_LANGUAGE_AB},
  {"af", WE_LANGUAGE_AF},
  {"am", WE_LANGUAGE_AM},
  {"ar", WE_LANGUAGE_AR},
  {"as", WE_LANGUAGE_AS},
  {"ay", WE_LANGUAGE_AY},
  {"az", WE_LANGUAGE_AZ},
  {"ba", WE_LANGUAGE_BA},
  {"be", WE_LANGUAGE_BE},
  {"bg", WE_LANGUAGE_BG},
  {"bh", WE_LANGUAGE_BH},
  {"bi", WE_LANGUAGE_BI},
  {"bn", WE_LANGUAGE_BN},
  {"bo", WE_LANGUAGE_BO},
  {"br", WE_LANGUAGE_BR},
  {"ca", WE_LANGUAGE_CA},
  {"co", WE_LANGUAGE_CO},
  {"cs", WE_LANGUAGE_CS},
  {"cy", WE_LANGUAGE_CY},
  {"da", WE_LANGUAGE_DA},
  {"de", WE_LANGUAGE_DE},
  {"dz", WE_LANGUAGE_DZ},
  {"el", WE_LANGUAGE_EL},
  {"en", WE_LANGUAGE_EN},
  {"eo", WE_LANGUAGE_EO},
  {"es", WE_LANGUAGE_ES},
  {"et", WE_LANGUAGE_ET},
  {"eu", WE_LANGUAGE_EU},
  {"fa", WE_LANGUAGE_FA},
  {"fi", WE_LANGUAGE_FI},
  {"fj", WE_LANGUAGE_FJ},
  {"fo", WE_LANGUAGE_FO},
  {"fr", WE_LANGUAGE_FR},
  {"fy", WE_LANGUAGE_FY},
  {"ga", WE_LANGUAGE_GA},
  {"gd", WE_LANGUAGE_GD},
  {"gl", WE_LANGUAGE_GL},
  {"gn", WE_LANGUAGE_GN},
  {"gu", WE_LANGUAGE_GU},
  {"ha", WE_LANGUAGE_HA},
  {"he", WE_LANGUAGE_HE},
  {"hi", WE_LANGUAGE_HI},
  {"hr", WE_LANGUAGE_HR},
  {"hu", WE_LANGUAGE_HU},
  {"hy", WE_LANGUAGE_HY},
  {"ia", WE_LANGUAGE_IA},
  {"wid", WE_LANGUAGE_ID},
  {"ie", WE_LANGUAGE_IE},
  {"ik", WE_LANGUAGE_IK},
  {"is", WE_LANGUAGE_IS},
  {"it", WE_LANGUAGE_IT},
  {"iu", WE_LANGUAGE_IU},
  {"ja", WE_LANGUAGE_JA},
  {"jw", WE_LANGUAGE_JW},
  {"ka", WE_LANGUAGE_KA},
  {"kk", WE_LANGUAGE_KK},
  {"kl", WE_LANGUAGE_KL},
  {"km", WE_LANGUAGE_KM},
  {"kn", WE_LANGUAGE_KN},
  {"ko", WE_LANGUAGE_KO},
  {"ks", WE_LANGUAGE_KS},
  {"ku", WE_LANGUAGE_KU},
  {"ky", WE_LANGUAGE_KY},
  {"la", WE_LANGUAGE_LA},
  {"ln", WE_LANGUAGE_LN},
  {"lo", WE_LANGUAGE_LO},
  {"lt", WE_LANGUAGE_LT},
  {"lv", WE_LANGUAGE_LV},
  {"mg", WE_LANGUAGE_MG},
  {"mi", WE_LANGUAGE_MI},
  {"mk", WE_LANGUAGE_MK},
  {"ml", WE_LANGUAGE_ML},
  {"mn", WE_LANGUAGE_MN},
  {"mo", WE_LANGUAGE_MO},
  {"mr", WE_LANGUAGE_MR},
  {"ms", WE_LANGUAGE_MS},
  {"mt", WE_LANGUAGE_MT},
  {"my", WE_LANGUAGE_MY},
  {"na", WE_LANGUAGE_NA},
  {"ne", WE_LANGUAGE_NE},
  {"nl", WE_LANGUAGE_NL},
  {"no", WE_LANGUAGE_NO},
  {"oc", WE_LANGUAGE_OC},
  {"om", WE_LANGUAGE_OM},
  {"or", WE_LANGUAGE_OR},
  {"pa", WE_LANGUAGE_PA},
  {"po", WE_LANGUAGE_PO},
  {"ps", WE_LANGUAGE_PS},
  {"pt", WE_LANGUAGE_PT},
  {"qu", WE_LANGUAGE_QU},
  {"rm", WE_LANGUAGE_RM},
  {"rn", WE_LANGUAGE_RN},
  {"ro", WE_LANGUAGE_RO},
  {"ru", WE_LANGUAGE_RU},
  {"rw", WE_LANGUAGE_RW},
  {"sa", WE_LANGUAGE_SA},
  {"sd", WE_LANGUAGE_SD},
  {"sg", WE_LANGUAGE_SG},
  {"sh", WE_LANGUAGE_SH},
  {"si", WE_LANGUAGE_SI},
  {"sk", WE_LANGUAGE_SK},
  {"sl", WE_LANGUAGE_SL},
  {"sm", WE_LANGUAGE_SM},
  {"sn", WE_LANGUAGE_SN},
  {"so", WE_LANGUAGE_SO},
  {"sq", WE_LANGUAGE_SQ},
  {"sr", WE_LANGUAGE_SR},
  {"ss", WE_LANGUAGE_SS},
  {"st", WE_LANGUAGE_ST},
  {"su", WE_LANGUAGE_SU},
  {"sv", WE_LANGUAGE_SV},
  {"sw", WE_LANGUAGE_SW},
  {"ta", WE_LANGUAGE_TA},
  {"te", WE_LANGUAGE_TE},
  {"tg", WE_LANGUAGE_TG},
  {"th", WE_LANGUAGE_TH},
  {"ti", WE_LANGUAGE_TI},
  {"tk", WE_LANGUAGE_TK},
  {"tl", WE_LANGUAGE_TL},
  {"tn", WE_LANGUAGE_TN},
  {"to", WE_LANGUAGE_TO},
  {"tr", WE_LANGUAGE_TR},
  {"ts", WE_LANGUAGE_TS},
  {"tt", WE_LANGUAGE_TT},
  {"tw", WE_LANGUAGE_TW},
  {"ug", WE_LANGUAGE_UG},
  {"uk", WE_LANGUAGE_UK},
  {"ur", WE_LANGUAGE_UR},
  {"uz", WE_LANGUAGE_UZ},
  {"vi", WE_LANGUAGE_VI},
  {"vo", WE_LANGUAGE_VO},
  {"wo", WE_LANGUAGE_WO},
  {"xh", WE_LANGUAGE_XH},
  {"yi", WE_LANGUAGE_YI},
  {"yo", WE_LANGUAGE_YO},
  {"za", WE_LANGUAGE_ZA},
  {"zh", WE_LANGUAGE_ZH},
  {"zu", WE_LANGUAGE_ZU}
};

const we_strtable_info_t we_languages = {
  we_languages_hash_table,
  WE_LANGUAGES_HASH_TABLE_SIZE,
  WE_TABLE_SEARCH_LINEAR,
  we_languages_strings,
  WE_LANGUAGES_STRING_TABLE_SIZE
};


/************************************************************ 
 * Local functions
 ************************************************************/

static int
we_hdr_find_by_int (we_hdr_t *hdr, int field_name);

static int
we_hdr_find_by_string (we_hdr_t *hdr, const char *name, int len);

static void
we_hdr_split_string (const char *value, int value_len, char split_char,
                      const char *parts[], int parts_len[], int *num_parts);

static int
we_hdr_expand (we_hdr_t *hdr);

static int
we_hdr_append_value (we_hdr_t *hdr, int idx, const char *value, int len,
                      int comma_separated);

static void
we_hdr_make_header_name (char *dst, const char *src);

static int
we_hdr_find_text_line (const char *text, const char **after_line);

static int
we_hdr_first_field (char *s);

static int
we_hdr_calculate_text_length (we_hdr_t* hdr);

static int
we_hdr_write_string (we_hdr_t* hdr, char *str);

static char *
we_hdr_escape_double_quote (WE_UINT8 module, const char *str);

static int
we_hdr_contains_reserved_chars (const char * str);

static char *
we_hdr_trim_param_str(WE_UINT8 module, const char *str);

static char *
we_hdr_trim_unquote_param_str(WE_UINT8 module, const char* str);



/************************************************************ 
 * Exported functions
 ************************************************************/

/*
 * Create a new, empty header table
 */ 
we_hdr_t *
we_hdr_create (WE_UINT8 module)
{
  we_hdr_t *hdr;

  hdr = WE_MEM_ALLOC (module, sizeof (we_hdr_t));
  if (hdr != NULL) {
    hdr->module = module;
    hdr->size = 0;
    hdr->max_size = WE_HDR_INITIAL_SIZE;
    hdr->last_added = -1;
    hdr->element = WE_MEM_ALLOC (module,
                                  sizeof (we_hdr_element_t) * WE_HDR_INITIAL_SIZE);
    if (hdr->element == NULL) {
      WE_MEM_FREE (hdr->module, hdr);
      hdr = NULL;
    }
  }

  return hdr;
}

/* 
 * Deallocate a header table and all its content 
 */
void
we_hdr_delete (we_hdr_t* hdr)
{
  int i;

  if (hdr != NULL) {
    for (i = 0; i < hdr->size; i++) {
      WE_MEM_FREE (hdr->module, hdr->element[i].name);
      WE_MEM_FREE (hdr->module, hdr->element[i].value);
    }
    WE_MEM_FREE (hdr->module, hdr->element);
    WE_MEM_FREE (hdr->module, hdr);
  }
}

/*
 * Copy a header table 
 */ 
we_hdr_t* 
we_hdr_copy (we_hdr_t* hdr)
{
  we_hdr_t *newhdr;
  int        i;
  char      *tmp1 = NULL, *tmp2;

  newhdr = WE_MEM_ALLOC (hdr->module, sizeof (we_hdr_t));
  if (newhdr == NULL)
    return NULL;

  newhdr->element = WE_MEM_ALLOC (hdr->module,
                                   sizeof (we_hdr_element_t) * hdr->max_size);
  if (newhdr->element == NULL) {
    WE_MEM_FREE (hdr->module, newhdr);
    return NULL;
  }

  newhdr->module = hdr->module;
  newhdr->size = hdr->size;
  newhdr->max_size = hdr->max_size;
  newhdr->last_added = hdr->last_added;
  for (i = 0; hdr->size; i++) {
    newhdr->element[i].name_i = hdr->element[i].name_i;
    if (((hdr->element[i].name != NULL) &&
         ((tmp1 = we_cmmn_strdup (hdr->module, hdr->element[i].name)) == NULL)) ||
        ((tmp2 = we_cmmn_strdup (hdr->module, hdr->element[i].value)) == NULL)) {
      newhdr->size = i;
      we_hdr_delete (newhdr);
      return NULL;
    }
    newhdr->element[i].name = tmp1;
    newhdr->element[i].value = tmp2;
  }

  return newhdr;
}


/*
 * Delete all fields of the specified kind.
 */
void
we_hdr_delete_field (we_hdr_t *hdr, int field_name)
{
  int i, j;

  for (i = 0, j = 0; i < hdr->size; i++) {
    if (hdr->element[i].name_i == field_name) {
      WE_MEM_FREE (hdr->module, hdr->element[i].name);
      WE_MEM_FREE (hdr->module, hdr->element[i].value);
    }
    else if (i != j) {
      hdr->element[j++] = hdr->element[i];
    }
    else {
      j++;
    }
  }

  hdr->size = j;
}


/************************************************************
 * Routines to add information to a header table. 
 ************************************************************/

/*
 * Add a string to the header table.
 * The string is copied into the table, and will be deallocated
 * when the header table is removed.
 * Returns TRUE on success and FALSE on error.
 */
int
we_hdr_add_string (we_hdr_t *hdr, int field_name, const char* value)
{
  int i;

  if ((hdr == NULL) || (value == NULL) ||
      (field_name < 0) || (field_name >= WE_HDR_UNKNOWN))
    return FALSE;

  i = we_hdr_find_by_int (hdr, field_name);
  if (i >= 0) {
    if (!we_hdr_append_value (hdr, i, value, strlen (value), TRUE))
      return FALSE;
  }
  else {
    if (hdr->size == hdr->max_size) {
      if (!we_hdr_expand (hdr))
        return FALSE;
    }
    i = hdr->size;
    hdr->element[i].name_i = field_name;
    hdr->element[i].name = NULL;
    hdr->element[i].value = we_cmmn_strdup (hdr->module, value);
    hdr->size++;
  }
  hdr->last_added = i;

  return TRUE;
}

/*
 * Add a parameter value to a header that is already in the table.
 * The string is copied, and will be deallocated when the header
 * table is deleted.
 * Returns TRUE on success, or FALSE on error.
 */
int
we_hdr_add_parameter (we_hdr_t *hdr, int field_name,
                       const char *parameter, const char* value)
{
  int   i;
  char *s, *tmp;

  if (hdr == NULL)
    return FALSE;

  i = we_hdr_find_by_int (hdr, field_name);
  if (i < 0)
    return FALSE;

  s = strstr (hdr->element[i].value, parameter);
  if (s != NULL)
    return FALSE;
  tmp = WE_MEM_ALLOC (hdr->module, strlen (hdr->element[i].value) +
                       strlen (parameter) + strlen (value) + 4);
  if (tmp == NULL)
    return FALSE;
  sprintf (tmp, "%s; %s=%s", hdr->element[i].value, parameter, value);
  WE_MEM_FREE (hdr->module, hdr->element[i].value);
  hdr->element[i].value = tmp;

  return TRUE;
}

/*
 * Parses one line of text as an HTTP header, and adds
 * the relevant content to the header table.
 * The parameter 'str' is a null-terminated character string holding
 * one line of text, and 'len' is the number of characters in 'str'.
 * Returns TRUE on success and FALSE on error.
 */
int
we_hdr_add_header_from_text_line (we_hdr_t *hdr, const char *str, int len)
{
  int         idx, namelen, valuelen, hdr_nbr;
  const char *name, *value;
  char       *tmp;

  
  /* First check if this is a continuation line, belonging to
   * the previous header. */
  if ((str[0] == ' ') || (str[0] == '\t')) {
    if (hdr->last_added < 0)
      return FALSE;
    return we_hdr_append_value (hdr, hdr->last_added, str, len, FALSE);
  }

  tmp = we_cmmn_strnchr(str, ':', len);
  if (tmp == NULL)
    return FALSE;
  value = we_cmmn_skip_blanks (tmp + 1);
  tmp--;
  while ((tmp > str) && (*tmp == ' '))
    tmp--;
  if (tmp == str)
    return FALSE;

  namelen = tmp - str + 1;
  name = str;
  hdr_nbr = we_cmmn_str2int_lc (name, namelen, &we_hdr_names);
  valuelen = we_cmmn_skip_trailing_blanks (value, len - (value - str));

  idx = we_hdr_find_by_int (hdr, hdr_nbr);
  if (idx < 0)
    idx = we_hdr_find_by_string (hdr, name, namelen);
  if (idx >= 0) {
    return we_hdr_append_value (hdr, idx, value, valuelen, TRUE);
  }

  if (hdr->size == hdr->max_size) {
    if (!we_hdr_expand (hdr))
      return FALSE;
  }

  /* If it is a header name that we do not know about,
   * store the text version of the name. */
  if ((hdr_nbr < 0) || (hdr_nbr >= WE_HDR_UNKNOWN)) {
    hdr->element[hdr->size].name_i = WE_HDR_UNKNOWN;
    if ((tmp = we_cmmn_strndup (hdr->module, name, namelen)) == NULL)
      return FALSE;
    hdr->element[hdr->size].name = tmp;
  }
  else {
    hdr->element[hdr->size].name_i = hdr_nbr;
    hdr->element[hdr->size].name = NULL;
  }
  if ((tmp = we_cmmn_strndup (hdr->module, value, valuelen)) == NULL) {
    WE_MEM_FREE (hdr->module, hdr->element[hdr->size].name);
    return FALSE;
  }
  hdr->element[hdr->size].value = tmp;
  hdr->last_added = hdr->size;
  hdr->size++;

  return TRUE;
}

/*
 * Given a text string that holds a number of lines, each
 * terminated by <CR><LF> (except perhaps the last one),
 * this function reads these lines and adds the header value to the table.
 * Returns TRUE on success and FALSE on error.
 */
int
we_hdr_add_headers_from_text (we_hdr_t *hdr, const char *text)
{
  const char *s, *p;
  int         len;

  if (text == NULL)
    return TRUE;

  p = text;
  for (;;) {
    s = p;
    len = we_hdr_find_text_line (s, &p);
    if (len == 0)
      break;

    if (!we_hdr_add_header_from_text_line (hdr, s, len))
      return FALSE;
  }

  return TRUE;
}


/**********************************************************************
 * Routines to retrieve information from a header table. 
 **********************************************************************/

/* 
 * Make a string out of the contents of a header structure.
 * Returns TRUE on success and FALSE on error.
 */
int
we_hdr_make_string (we_hdr_t *hdr, char **str)
{
  int len;
   
  len = we_hdr_calculate_text_length (hdr);
  
  if (len == 0) {
    *str = NULL;
  }
  else {
    *str = (char*)WE_MEM_ALLOC (hdr->module, len + 1);
    if (*str == NULL)
      return FALSE;
    if (!we_hdr_write_string (hdr, *str))
      return FALSE;
  }

  return TRUE;
}

/*
 * Get a WE_UINT32 value from the first element with the given header name.
 * Returns TRUE if a header element was found, and FALSE otherwise.
 */
int
we_hdr_get_uint32 (we_hdr_t *hdr, int field_name, WE_UINT32 *uval)
{
  int         i, len;
  WE_UINT32  u = 0;
  char       *value;

  /* Locate the header, and try to convert the string into an integer */
  for (i = 0; i < hdr->size; i++) {
    if (hdr->element[i].name_i == field_name) {
      value = hdr->element[i].value;
      switch (field_name) {
      case WE_HDR_DATE:
      case WE_HDR_EXPIRES:
      case WE_HDR_IF_MODIFIED_SINCE:
      case WE_HDR_IF_UNMODIFIED_SINCE:
      case WE_HDR_LAST_MODIFIED:
        if (!we_cmmn_str2time (value, &u))
          return FALSE;
        break;

        /* This header has either a HTTP-date or an integer as value. */
      case WE_HDR_RETRY_AFTER:
        if (ct_isdigit (value[0])) {
          u = atol (value);
        }
        else {
          if (!we_cmmn_str2time (value, &u))
            return FALSE;
        }
        break;

      case WE_HDR_AGE:
      case WE_HDR_CONTENT_LENGTH:
        u = atol (value);
        break;

      case WE_HDR_ACCEPT:
      case WE_HDR_CONTENT_TYPE:
      case WE_HDR_X_WAP_PUSH_ACCEPT:
        len = we_hdr_first_field (value);
        u = we_cmmn_str2int_lc (value, len, &we_mime_types);
        break;

      case WE_HDR_ACCEPT_CHARSET:
      case WE_HDR_X_WAP_PUSH_ACCEPT_CHARSET:
        len = we_hdr_first_field (value);
        u = we_charset_str2int (value, len); 
        break;

      case WE_HDR_ACCEPT_LANGUAGE:
      case WE_HDR_CONTENT_LANGUAGE:
      case WE_HDR_X_WAP_PUSH_ACCEPT_LANGUAGE:
        break;

      case WE_HDR_ACCEPT_APPLICATION:
        break;

      default:
        /* This is not a header whose value we can convert to an integer */
        return FALSE;
      }

      *uval = u;
      return TRUE;
    }
  }

  return FALSE;
}

/*
 * Get a string value from the first element with the given header name.
 * Returns NULL if the requested header element is not in the table.
 * NOTE: the caller MUST NOT deallocate the returned string!
 */
const char *
we_hdr_get_string (we_hdr_t *hdr, int field_name)
{
  int i;

  i = we_hdr_find_by_int (hdr, field_name);
  if (i < 0)
    return NULL;
  else
    return hdr->element[i].value;
}

char *
we_hdr_get_parameter (we_hdr_t *hdr, int field_name, const char *parameter)
{
  int         i, len;
  char       *s, *value = NULL;
  const char *parts[8];
  int         parts_len[8];
  int         num_parts;

  for (i = 0; i < hdr->size; i++) {
    if (hdr->element[i].name_i == field_name) {
      break;
    }
  }
  if (i < hdr->size) {
    num_parts = 1;
    we_hdr_split_string (hdr->element[i].value, strlen (hdr->element[i].value), ',',
                          parts, parts_len, &num_parts);
    if (num_parts >= 1) {
      num_parts = 8;
      we_hdr_split_string (parts[0], parts_len[0], ';', parts, parts_len, &num_parts);
      for (i = 1; i < num_parts; i++) {
        s = we_cmmn_strnchr (parts[i], '=', parts_len[i]);
        if (s != NULL) {
          len = we_cmmn_skip_trailing_blanks (parts[i], s - parts[i]);
          if (we_cmmn_strncmp_nc (parts[i], parameter, len) == 0) {
            s = we_cmmn_skip_blanks (s + 1);
            len = parts_len[i] - (s - parts[i]);
            if (*s == '"' && len > 1 && s[len-1] == '"') {
              s++;
              len -= 2;
            }
            if ( len > 0 ) {
              /* In case of a corrupt header and the string is just
                 a bunch of white spaces, len will be < 0. This causes 
                 a crash in we_cmmn_strndup. In this case value will be
                 NULL */
              value = we_cmmn_strndup (hdr->module, s, len);
            }
            break;
          }
        }
      }
    }
  }

  return value;
}

/**********************************************************************
 * Routines to build up and parse header parameter strings 
 **********************************************************************/


/* 
 *    Converts the strings param_name and param_value parameters to be 
 *  uniquely identified according to the HTTP/1.1 header encoding. 
 *  This implies that the name parameters are token strings, as defined 
 *  by HTTP/1.1, i.e. no presence of CTL's (US-ASCII 0x00 - 0x1F, 0x7F) 
 *  or reserved separators below: 
 *  
 *  '('  ')'  '<'  '>'  '@'  
 *  ','  ';'  ':'  '\'  '"'  
 *  '/'  '['  ']'  '?'  '='
 *  '{'  '}'  SPACE (0x20)  HTAB (0x09)
 *  
 *
 *  IF A FORBIDDEN CHARACTER IS ENCOUNTERED INSIDE A NAME ATTRIBUTE 
 *  THE WHOLE PARAMETER PAIR IS DISCARDED!
 *
 *  This restriction does not apply to the strings in the value array. 
 *  Values are transformed to quoted strings ( val(ue -> "val(ue" ) 
 *  with quoted pairs ( val"ue -> "val\"ue" ) if required.
 *    Returns:
 *        A string with the parameter pairs concatenated in consecutive order, 
 *    
 *    e.g param_name[0] = name1, param_value[0] = NULL
 *        param_name[1] = name2, param_value[1] = val(ue2
 *
 *    returns  name1;name2="val(ue2"
 *
 *  Note: The caller is responsible for for deallocating the returned
 *  memory buffer.
 */
char *
we_hdr_build_param_list (WE_UINT8 module, int num_params, 
                          const char *param_name[], const char *param_value[])
{
  char *tmp_p = NULL; 
  char *conv_name = NULL;
  char *conv_value = NULL;
  char *result_str = NULL;
  int   i;

  for (i = 0; i < num_params; i++) {
  
    /* If a param_name is empty, the whole pair is discarded */
    if (param_name[i] == NULL)
      continue;



    if (WE_HDR_IS_QUOTED_STRING(param_name[i])) {
      /* Name string is quoted, does not conform to the HTTP/1.1 
         convention, discarding param */
      continue;
    }
    else {
      if (we_hdr_contains_reserved_chars(param_name[i])) {
        /* parameter name does not conform to the HTTP/1.1 convention, 
           discarding param */
        continue;
      }
      else /* the name is a valid token string, keep it as it is */
        conv_name = we_cmmn_strdup(module, param_name[i]);
    }

    /* If the parameter value is missing the parameter is regarded as a boolean */
    if (param_value[i] != NULL) {
      
      if (WE_HDR_IS_QUOTED_STRING(param_value[i])) {
        /* String is qouted, check it for unescaped qoutes */
        conv_value = we_hdr_escape_double_quote(module, param_value[i]);
      }
      else {
        if (we_hdr_contains_reserved_chars(param_value[i])) {   
          tmp_p = we_cmmn_str3cat(module, (const char *) WE_HDR_STR_DOUBLE_QUOTE,
                                   param_value[i], 
                                   (const char *) WE_HDR_STR_DOUBLE_QUOTE);

          conv_value = we_hdr_escape_double_quote(module, tmp_p); 

          if (tmp_p != NULL) {
            WE_MEM_FREE(module, (void *)tmp_p);
            tmp_p = NULL;
          }
        }
        else /* the name is a valid token string, keep it as it is */
          conv_value = we_cmmn_strdup(module, param_value[i]);
      }
    }

    /* parameter content formatted, build result string */
    if (result_str)
      tmp_p = we_cmmn_str3cat (module, (const char *)result_str,
                                (const char *) WE_HDR_STR_SEMI_COMMA, 
                                (const char *) conv_name);
    else {
      tmp_p = conv_name;
      conv_name = NULL;
    }

    if (conv_value) {

      if (result_str)
        WE_MEM_FREE(module, result_str);

      result_str = we_cmmn_str3cat (module, (const char *) tmp_p, 
                                     (const char *) WE_HDR_STR_EQUAL, 
                                     (const char *) conv_value);
    }
    else {
      if (result_str)
        WE_MEM_FREE(module, result_str);
      
      result_str = tmp_p;
      tmp_p = NULL;
    }
    
    WE_HDR_MEM_FREE_AND_RESET(module, tmp_p);

    WE_HDR_MEM_FREE_AND_RESET(module, conv_name);

    WE_HDR_MEM_FREE_AND_RESET(module, conv_value);
  } /* for() */


  
  return result_str;
}


/*
 *    Unpacks the parameter list into a name array and a corresponding value array.
 *  If a parameter name's corresponding value pair is not encountered its value 
 *  string pointer will point at NULL. This is the reverse function of
 *  we_hdr_build_parameter_string(). See its description header for more details.
 *
 *    Returns:
 *        The number of parameters that were found in the string, if this number 
 *    exceeds the max_params only the given number of parameters was retrieved. 
 *    the operation have to be redone with array sizes the returned int tells
 *    in order to retrieve all parameters. 
 *
 *  
 *  Note 1: The caller is responsible for for deallocating the
 *  memory buffers attached to the param_name and param_value arrays after the 
 *  function returns. 
 *
 *  Note 2: The arrays should not contain any pointers when used in this function.
 *  All array pointers will be reset by the function, if an array slot points out a
 *  memory buffer it might result in a leak!
 */

int
we_hdr_get_params (WE_UINT8 module, const char *param_list, 
                    int max_params, char *param_name[], char *param_value[])
{
  int   i = 0;
  int   param_count = 0;
  char *tmp_p = NULL;
  char *c = NULL;
  int   inside_quoted_str = FALSE;
  
  c = (char *) param_list;

  if (c == NULL)
    return param_count;

  i = 0;

  /* avoid wild pointers */
  while (i < max_params) {
    param_name[i] = NULL;
    param_value[i] = NULL;
    i++;
  }

  /* Skip any leading blanks */
  while ((*c == WE_HDR_CH_BLANK))
    c++;

  if ((*c != WE_HDR_CH_SEMI_COMMA) && (*c != '\0')) {
    if (param_count < max_params)
        param_name[param_count] = c;
      param_count++;
  }
  
  /* traverse the string */
  while (*c != '\0') {
    /* check if it is a parameter delimiter ';' */
    if ((!inside_quoted_str) && (*c == WE_HDR_CH_SEMI_COMMA) && (*(c+1) != '\0')) {
      if (param_count <= max_params) {
        if (param_count < max_params)
          param_name[param_count] = c+1;

        if (param_count) {
          tmp_p = param_value[param_count-1];

          if (!tmp_p) {

            tmp_p = param_name[param_count-1];
          
            param_name[param_count-1] = WE_MEM_ALLOC(module, (c -tmp_p)+1);

            if (!param_name[param_count-1])
              return -1;
            strncpy (param_name[param_count-1], (const char *) tmp_p, (c - tmp_p));

            param_name[param_count-1][c-tmp_p] = '\0';
          }
          else {
            param_value[param_count-1] = WE_MEM_ALLOC(module, (c -tmp_p)+1);

            if (!param_value[param_count-1])
              return -1;
            strncpy (param_value[param_count-1], (const char *) tmp_p, (c - tmp_p));

            param_value[param_count-1][c-tmp_p] = '\0';
          }
          
        }
      }
      param_count++;
    }
    /* check if it is a value delimiter '=' */
    else if ((!inside_quoted_str) && (*c == WE_HDR_CH_EQUAL) && (*(c+1) != '\0')) {
      if ((param_count) && (param_count <= max_params)){
        param_value[param_count-1] = c+1;

        tmp_p = param_name[param_count-1];

        param_name[param_count-1] = WE_MEM_ALLOC(module, (c - tmp_p)+1);
                                                            
        if (!param_name[param_count-1])
          return -1;

        strncpy (param_name[param_count-1], (const char *) tmp_p, (c - tmp_p));

        param_name[param_count-1][c-tmp_p] = '\0';
        
      }
      else if (!param_count)
        return -1; /* Malformatted parameter string */
    }
    /* check if it is a quoted string delimiter. If so, set escaped to TRUE */
    else if (*c == WE_HDR_CH_DOUBLE_QUOTE) {
      if (c == param_list) {
        inside_quoted_str = TRUE;
      }
      else if (*(c-1) != WE_HDR_CH_BACKSLASH)
        inside_quoted_str = !inside_quoted_str;
    }
    
    c++;
  }    

  /* Copy the last parameter/value */
  if (param_count <= max_params) {

    if (param_count) {
      tmp_p = param_value[param_count-1];

      if (!tmp_p) {

        tmp_p = param_name[param_count-1];
      
        param_name[param_count-1] = WE_MEM_ALLOC(module, (c -tmp_p)+1);

        if (!param_name[param_count-1])
          return -1;
        strncpy (param_name[param_count-1], (const char *) tmp_p, (c - tmp_p));

        param_name[param_count-1][c-tmp_p] = '\0';
      }
      else {
        param_value[param_count-1] = WE_MEM_ALLOC(module, (c -tmp_p)+1);

        if (!param_value[param_count-1])
          return -1;
        strncpy (param_value[param_count-1], (const char *) tmp_p, (c - tmp_p));

        param_value[param_count-1][c-tmp_p] = '\0';
      }
    }
  }

  /* Trim and unquote the value strings */
  for (i = 0; i < max_params; i++) {
    if (param_name[i]) {
      tmp_p = param_name[i];
      param_name[i] = we_hdr_trim_param_str(module, tmp_p);
      WE_MEM_FREE(module, tmp_p);
      if(!param_name[i])
        return -1;
    }
    if (param_value[i]) {
      tmp_p = param_value[i];
      param_value[i] = we_hdr_trim_unquote_param_str(module, tmp_p);
      WE_MEM_FREE(module, tmp_p);
      if(!param_value[i])
        return -1;
    }
  }
 
  return param_count;
}

/**********************************************************************
 * Local functions
 **********************************************************************/

static int
we_hdr_find_by_int (we_hdr_t *hdr, int field_name)
{
  int i;

  for (i = 0; i < hdr->size; i++) {
    if (hdr->element[i].name_i == field_name) {
      return i;
    }
  }

  return -1;
}

static int
we_hdr_find_by_string (we_hdr_t *hdr, const char *name, int len)
{
  int i;

  for (i = 0; i < hdr->size; i++) {
    if ((hdr->element[i].name != NULL) &&
        (we_cmmn_strncmp_nc (hdr->element[i].name, name, len) == 0)) {
      return i;
    }
  }

  return -1;
}

static int
we_hdr_expand (we_hdr_t *hdr)
{
  int                i;
  int                new_max_size = hdr->max_size + WE_HDR_SIZE_INCREMENT;
  we_hdr_element_t *elt = WE_MEM_ALLOC (hdr->module,
                                          new_max_size * sizeof (we_hdr_element_t));

  if (elt == NULL)
    return FALSE;

  for (i = 0; i < hdr->size; i++) {
    elt[i] = hdr->element[i];
  }
  WE_MEM_FREE (hdr->module, hdr->element);
  hdr->element = elt;
  hdr->max_size = new_max_size;

  return TRUE;
}

static void
we_hdr_split_string (const char *value, int value_len, char split_char,
                      const char *parts[], int parts_len[], int *num_parts)
{
  const char *s, *t;
  const char *endp = value + value_len;
  char        qc;
  int         slen;
  int         n = 0;

  t = value;
  do {
    s = we_cmmn_skip_blanks (t);
    for (t = s; (t < endp) && (*t != split_char); t++) {
      if ((t[0] == '"') || (t[0] == '\'')) {
        qc = t[0];
        t = strchr (t + 1, qc);
        if ((t == NULL) || (t >= endp)) {
          goto done;
        }
      }
    }
    slen = we_cmmn_skip_trailing_blanks (s, t - s);
    parts[n] = s;
    parts_len[n++] = slen;
    if (n >= *num_parts) {
      break;
    }
    t++;
  } while (t < endp);

 done:
  *num_parts = n;
}

static int
we_hdr_append_value (we_hdr_t *hdr, int idx, const char *value, int len,
                      int comma_separated)
{
  const char *s;
  char       *tmp, *p;
  int         oldlen, newlen;

  s = we_cmmn_skip_blanks (value);
  len = we_cmmn_skip_trailing_blanks (s, len - (s - value));
  oldlen = strlen (hdr->element[idx].value);
  newlen = oldlen + len + 1;
  if (comma_separated)
    newlen++;

  p = tmp = WE_MEM_ALLOC (hdr->module, newlen + 1);
  if (tmp == NULL)
    return FALSE;
  strcpy (p, hdr->element[idx].value);
  p += oldlen;
  if (comma_separated) {
    strcpy (p, ", ");
    p += 2;
  }
  else {
    strcpy (p, " ");
    p += 1;
  }
  strncpy (p, s, len);
  p[len] = '\0';
  WE_MEM_FREE (hdr->module, hdr->element[idx].value);
  hdr->element[idx].value = tmp;
  hdr->last_added = idx;

  return TRUE;
}

static void
we_hdr_make_header_name (char *dst, const char *src)
{
  const char *s;
  int         first = 1;

  for (s = src; *s != '\0'; s++) {
    if (first) {
      if (ct_isalpha (*s) && ct_islower (*s))
        *dst++ = (char)(*s + 'A' - 'a');
      else
        *dst++ = *s;
      first = 0;
    }
    else {
      *dst++ = *s;
      if (!ct_isalphanum (*s))
        first = 1;
    }
  }
  *dst++ = ':';
  *dst++ = ' ';
  *dst = '\0';
}

static int
we_hdr_find_text_line (const char *text, const char **after_line)
{
  const char *s;

  *after_line = NULL;
  if (text == NULL) {
    return 0;
  }

  for (s = text; *s; s++) {
    if (s[0] == '\r') {
      if (s[1] == '\n') {
        *after_line = s + 2;
        break;
      }
      else if (s[1] == '\0') {
        *after_line = s + 1;
        break;
      }
    }
    else if (s[0] == '\n') {
      *after_line = s + 1;
      break;
    }
  }

  return s - text;
}

static int
we_hdr_first_field (char *s)
{
  char *p;

  for (p = s; *p && (*p != ',') && (*p != ';'); p++);

  return p - s;
}

/*
 * Calculate the total length of the headerstream that needs to be built,
 * and return the result.
 */
static int
we_hdr_calculate_text_length (we_hdr_t* hdr)
{
  int         len = 0;
  int         i;
  const char *name;
  
  for (i = 0; i < hdr->size; i++) {
    if (hdr->element[i].name != NULL) {
      name = hdr->element[i].name;
    }
    else {
      name = we_cmmn_int2str (hdr->element[i].name_i, &we_hdr_names);
    }
    if (name != NULL) {
      len += strlen (name) + 2;  /* extra 2 for ": " */
    }
    len += strlen (hdr->element[i].value) + 2; /* extra 2 for <CR><LF> */
  }

  return len;
}

/*
 * The main function for creating the textual header 
 * Returns TRUE on sucess, else FALSE.
 */
static int
we_hdr_write_string (we_hdr_t* hdr, char *str)
{
  int            i;
  int            len;
  const char    *name;
  char          *s = str;

  for (i = 0; i < hdr->size; i++) {
    if (hdr->element[i].name != NULL) {
      name = hdr->element[i].name;
    }
    else {
      name = we_cmmn_int2str (hdr->element[i].name_i, &we_hdr_names);
    }
    if (name == NULL)
      return FALSE;

    we_hdr_make_header_name (s, name);
    s += strlen (name) + 2;

    len = strlen (hdr->element[i].value);
    strcpy (s, hdr->element[i].value);
    s += len;

    strcpy (s, "\r\n");
    s += 2;
  }

  return TRUE;
}

                                  
/*
 *    Utility function that scans the string for the double quote character. 
 *  All occurrences are replaced with an escaped representation of the characters.
 *
 *  Returns:
 *    A string with escaped double quotes
 *  
 *  Note: The caller is responsible for deallocating the returned memory buffer.
 */
static char *
we_hdr_escape_double_quote (WE_UINT8 module, const char *str)
{
  char *c = NULL;
  char *result_str = NULL;
  int   num_of_occurrences = 0;
  int   new_str_len = 0;
  int   i = 0;
  
  if (!str)
    return NULL;
  
  /* Scan for any occurrencies of the double quote character */
  c = strchr (str, (int) WE_HDR_CH_DOUBLE_QUOTE);

  if (!c) { /* double quote not found, we're done */
    
    return we_cmmn_strdup(module, str);
  }
  
  /* calculate the size for the new string */
  while (*c != '\0') {
    /* Don't count the double quotes in the beginning or end, 
       or already escaped double quotes. */ 
    if ((*c == WE_HDR_CH_DOUBLE_QUOTE) && (c != str) && 
        (c != (str + strlen(str)-1)) && (*(c-1) != WE_HDR_CH_BACKSLASH))
      num_of_occurrences++;
    c++;
  }

  /* Check if the first and last characters are double quotes, 
     if so, and no other were found, we're done */
  if ((*str == WE_HDR_CH_DOUBLE_QUOTE) &&
    (*(str + strlen(str)-1) == WE_HDR_CH_DOUBLE_QUOTE)) {
      if (!num_of_occurrences)
        return we_cmmn_strdup(module, str);
  }

  new_str_len = strlen (str) + (num_of_occurrences * sizeof(char)) +1;

  result_str = WE_MEM_ALLOC(module, new_str_len);

  if (!result_str)
    return NULL;

  c = (char *) str;
  /* copy the string, insert escape characters where applicable */
  i = 0;
  while (*c != '\0') {
    if ((*c == WE_HDR_CH_DOUBLE_QUOTE) && (c != str) && 
        (c != (str + strlen(str)-1)) && (*(c-1) != WE_HDR_CH_BACKSLASH)) {
      result_str[i] = WE_HDR_CH_BACKSLASH;
      i++;
    }
    result_str[i] = *c;
    i++;
    c++;
  }

  result_str[i] = '\0';

  return result_str;
}



/*
 *    Utility function that scans str for reserved characters.
 *
 *  Returns
 *    TRUE if a reserved character was found, otherwise FALSE
 */
static int
we_hdr_contains_reserved_chars (const char * str)
{
  char *c = (char *) str;

  if (!c)
    return FALSE;

  while (*c != '\0') {
    if (ct_isctrl(*c) || ct_istspecial(*c))
      return TRUE;
    c++;
  }

  return FALSE;
}


/*
 *    Takes a string and trims consecutive blanks from its head and tail
 *
 *  Returns
 *    A trimmed string.
 *
 *  Note: The caller is responsible for for deallocating the returned
 *  memory buffer.
 */
static char *
we_hdr_trim_param_str(WE_UINT8 module, const char *str)
{
  char *head = (char *) str;
  char *tail = NULL;
  char *trimmed_str = NULL;
  int   head_blanks = 0;
  int   tail_blanks = 0;
  int   trimmed_str_len = 0;

  if (!str)
    return NULL;

  tail = (char *) (str + strlen(str)-1);

  while ((*head == WE_HDR_CH_BLANK) && (head != tail)) {
    head_blanks++;
    head++;
  }

  while ((*tail == WE_HDR_CH_BLANK) && (head != tail)) {
    tail_blanks++;
    tail--;
  }

  trimmed_str_len = (tail + 1 - head);

  trimmed_str = WE_MEM_ALLOC(module, trimmed_str_len + 1);
  if (!trimmed_str)
    return NULL;
  strncpy(trimmed_str, head, trimmed_str_len);

  trimmed_str[trimmed_str_len] = '\0';
  
  return trimmed_str;
}


/*
 *    Takes a string and trims consecutive blanks from its head and tail.
 *  Moreover it removes double quotes from its head and tail, and removes 
 *  quoted pairs if any found.
 *
 *  Returns
 *    A trimmed string, non-double quoted.
 *
 *  Note: The caller is responsible for for deallocating the returned
 *  memory buffer.
 */
static char *
we_hdr_trim_unquote_param_str(WE_UINT8 module, const char* str)
{
  char *head = (char *) str;
  char *tail = NULL;
  char *trimmed_str = NULL;
  char *c = NULL;
  int   head_blanks = 0;
  int   tail_blanks = 0;
  int   num_escapes = 0;
  int   i = 0;
  int   trimmed_str_len = 0;

  if (!str)
    return NULL;

  tail = (char *) (str + strlen(str)-1);

  while ((*head == WE_HDR_CH_BLANK) && (head != tail)) {
    head_blanks++;
    head++;
  }

  while ((*tail == WE_HDR_CH_BLANK) && (head != tail)) {
    tail_blanks++;
    tail--;
  }

  if ((*head == WE_HDR_CH_DOUBLE_QUOTE) && (*tail == WE_HDR_CH_DOUBLE_QUOTE)) {
    head++;
    tail--;
    if (tail <= head)
      return NULL;
    /* check if the string contains any escaped double quotes that 
       should be reset */
    c = head;
    
    while (c != (tail+1)) {
      if ((*c == WE_HDR_CH_DOUBLE_QUOTE) && (c != head) && 
          (*(c-1) == WE_HDR_CH_BACKSLASH))
        num_escapes++;
      c++;
    }
  }
  trimmed_str_len = (tail +1 - head) - num_escapes;

  trimmed_str = WE_MEM_ALLOC(module, trimmed_str_len + 1);
  if (!trimmed_str)
    return NULL;
  
  c = head;
  while (c != (tail+1)) {
    if ((*c == WE_HDR_CH_BACKSLASH) && (*(c+1) == WE_HDR_CH_DOUBLE_QUOTE))
      c++;
    trimmed_str[i] = *c;
    i++;
    c++;
  }


  trimmed_str[trimmed_str_len] = '\0';
  
  return trimmed_str;
}

